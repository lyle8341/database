- 脏读:A事务读取B事务尚未提交的更改数据，并在这个数据基础上操作，如果B事务回滚，那么A事务读到的数据根本不是合法的。
- 不可重复读:A事务读取了B事务已经提交的**更改**(或删除)数据。
- 幻读:A事务读取了B事务已经提交的**新增**数据。
- 可重复读:B事务中提交了一条新记录，A事务是看不到的，但是A事务插入相同记录时发现已经存在该记录，仿佛之前读取的"幻影"

- 乐观锁:（Optimistic Concurrency Control，OCC）乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时不加锁，而在进行更新时去判断是否有冲突了
  - 先进行业务操作，不到万不得已不去拿锁
- 悲观锁:（Pessimistic Concurrency Control，PCC）悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。共享锁和排它锁是悲观锁的不同的实现。
  - 先获取锁，再进行业务操作
  - select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用
  - mysql中select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。
- InnoDB支持三种行锁定方式：
  - 行锁（Record Lock）：行锁是通过给索引上的索引项加锁来实现的
    - 共享锁(S):
    - 排它锁(X):
  - 间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。
  - Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。
- 表锁  
  - 意向共享锁(IS):事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁
  - 意向排它锁(IX):事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

- mysql给用户提供了加锁的机会
  - 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  - 排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE
  - 自己加的锁没有释放锁的语句，所以锁会持有到事务结束。
  
  
  
  
http://blog.itpub.net/15498/viewspace-2141515/
