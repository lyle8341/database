#### innodb的锁

1 . 乐观锁:(Optimistic Concurrency Control，OCC)乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时不加锁，而在进行更新时去判断是否有冲突了
  * _乐观锁是一种思想，它其实并不是一种真正的『锁』_
  * 先进行业务操作，不到万不得已不去拿锁



2 . 悲观锁:(Pessimistic Concurrency Control，PCC)悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。共享锁和排它锁是悲观锁的不同的实现。
  * 先获取锁，再进行业务操作
  * select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用
  * mysql中select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。
  * 共享锁
  
  
  * 排它锁
    - 记录锁（Record Lock）：行锁是通过给索引上的索引项加锁来实现的
      - 共享锁(S-读锁):
      - 排它锁(X-写锁):
      - 共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容
    - 间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。
      - **间隙锁只存在于RR隔离级别下的辅助索引中，只锁定一个范围，但不包含记录本身**
      - 对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁
      - 间隙锁有一个致命的弱点，就是当锁定一个范围值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入值范围内的任何数据
      - *间隙锁在InnoDB的唯一作用就是防止其它事务的插入操作*
      - 要禁止间隙锁的话，可以把隔离级别降为读已提交，或者开启参数innodb_locks_unsafe_for_binlog
      - 如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会*插入* **新的满足条件的记录**并提交。为了实现这个功能，GAP锁应运而生。
    - 临键锁（Next-Key Lock）：行锁与间隙锁组合起来用就叫做Next-Key Lock。
      - 通过临建锁可以解决幻读的问题。 每个数据行上的**非唯一索引**列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。
      - InnoDB 中行级锁是基于索引实现的，**临键锁只与非唯一索引列有关**，在唯一索引列（包括主键列）上不存在临键锁

* 隔离级别
  - 脏读:A事务读取B事务尚未提交的更改数据，并在这个数据基础上操作，如果B事务回滚，那么A事务读到的数据根本不是合法的。
  - 不可重复读:A事务读取了B事务已经提交的**更改**(update和delete)数据。
  - 幻读
    - A事务读取了B事务已经提交的**新增**(insert)数据。eg:B事务中提交了一条新记录，A事务是看不到的，但是A事务插入相同记录时发现已经存在该记录，仿佛之前读取的"幻影"
    - 所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。
- 表锁
  - 为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念 
  - 意向共享锁(IS):事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁
  - 意向排它锁(IX):事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁
  - 自增锁,自增锁是一个特殊的表级锁，事务插入自增列的时候需要获取，最简单情况下如果一个事务插入一个值到表中，任何其他事务都要等待，这样第一个事物才能获得连续的主键值
    - innodb_autoinc_lock_mode配置选项控制了自增锁的算法
  - 意向锁
    - 主要目的是为了表示是否有人请求锁定表中的某一行数据。
    - 如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。


- innodb使用表锁
  ```sql
  SET AUTOCOMMIT=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  [do something with tables t1 and t2 here];
  COMMIT;
  UNLOCK TABLES;
  ```
  - 这种情况建议使用MyISAM引擎
- 显式锁
  - 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  - 排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE
  - 自己加的锁没有释放锁的语句，所以锁会持有到事务结束。

- 隐式锁
  - InnoDB自动加意向锁。
  - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
  - 对于普通SELECT语句，InnoDB不会加任何锁；
  

